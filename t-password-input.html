<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../t-input/t-input.html" />
<!--
`t-password-input` is a password field which uses t-input and custom validation
Examples:

    <t-password-input></t-password-input>
    <t-password-input no-validation></t-password-input>
    <t-password-input no-default-validation></t-password-input>
    <t-password-input custom-regex-rules='
    [{"lower-case1":{"message":"This is a custom lower case regex","regex":"[a-z]"}}]'></t-password-input>
    
You can pass in your custom validation in this component by passing an array of objects in the below mentioned format.
   var customRegex =    [{
                            'key-name' : {
                                message:'custom message',
                                regex:'regex string'
                            }
                        }];

### Styling

The following properties are used for styling:

Custom property | Description | Default
----------------|-------------|----------
`--error-color` | Color of invalid point | `#FF0000`
`--success-color` | Color of valid point | `#7fad4d`
`--grey-three` | Default color of points | `#bbbbbb`

-->
<dom-module id="t-password-input">
    <template>
        <style>
        :host {
            display: block;
            font-family: var(--primary-font-family);
            font-size: var(--font-12, 12px);
        }
        
        p {
            margin: 0;
            padding-left: 15px;
            position: relative;
            color: var(--grey-three, #bbbbbb);
        }
        
        p::before {
            content: "•";
            position: absolute;
            left: 0;
            color: inherit;
        }
        
        .valid {
            opacity: 0.5;
        }
        
        .valid::before {
            content: "✔";
            color: var(--success-color, #7fad4d);
        }
        
        .input-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        ::content input {
            padding-right: 50px!important;
        }
        
        #togglePassword {
            background: var(--grey-three, #bbbbbb);
            color: var(--secondary-text-color, #ffffff);
            cursor: pointer;
            padding: 2px 7px;
            border-radius: 2px;
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
        }
        </style>
        <div class="input-container">
            <t-input id="password" type="password" on-value-changed="_validateRegex" value="{{value::input}}" label="{{label}}" error-message="You missed this." required auto-validate></t-input>
            <template is="dom-if" if="[[!noShowHide]]">
                <div id="togglePassword" class$="{{_toggleClass}}" on-click="_togglePaswordVisibility">
                    [[_toggleClass]]
                </div>
            </template>
        </div>
        <template is="dom-if" if="[[!noValidation]]">
            <template is="dom-repeat" items="{{regexRules}}">
                <p class$="{{item.status}} || base">
                    {{item.message}}
                </p>
            </template>
        </template>
    </template>
</dom-module>

<script>

    Polymer({

        is: 't-password-input',

        properties: {

            /**
             * The value for this input. 
             */
            value: {
                type: String,
                notify: true
            },

            /**
             * Set this to true for applying no custom validation(required validator will run always).
             */
            noValidation: {
                type: Boolean,
                value: false
            },

            /**
             * Set this to true to skip default validations
             */
            noDefaultValidation: {
                type: Boolean,
                value: false
            },

            /**
             * Set this to true for hiding show hide button.
             */
            noShowHide: {
                type: Boolean,
                value: false
            },

            /**
             * Sets the password input label.
             */
            label: {
                type: String,
                value: 'Password'
            },

            /**
             * This is the deafult array of the regex rules.
             * This is used if showMessaging flag is set to true (default is false)
             * This list is modified/overridden if custom messages are provided
             * It is a read only field
             */
            defaultRegexRules: {
                type: Array,
                value: [{
                    'lower-case': {
                        message: 'One lower case character',
                        regex: "[a-z]"
                    }
                }, {
                    'upper-case': {
                        message: 'One upper case character',
                        regex: "[A-Z]"
                    }
                }, {
                    'number': {
                        message: 'One number',
                        regex: "[0-9]"
                    }
                }, {
                    'special-char': {
                        key: 'special-char',
                        message: 'One special character',
                        regex: "[!@#$%^&*()_+=?]"
                    }
                }, {
                    'min-length': {
                        key: 'min-length',
                        message: '8 characters minimum',
                        regex: /^.{8,99}$/
                    }
                }],
                readOnly: true
            },

            /**
             * This is modified regex rules array.
             * This array is used in the application.
             * It is a copy of default regex rules if custom rules are not provided
             * It is a read only field
             */
            regexRules: {
                type: Array,
                readOnly: true
            },

            /**
             * This is a stringified array of custom regex rules.
             * This array modifies/overrides default validation rules.
             * Each regex rule is provided with unique key

                *Regex Rule Object*
                {
                    'key-name' : {
                        message:'custom message',
                        regex:'regex string'
                    }
                }
             * If the key matches existing default keys, default rule gets overridden.
             */
            customRegexRules: String,

            _toggleClass: {
                type: String,
                value: 'Show'
            }
        },

        attached: function() {
            this._updateRegexRules();
        },

        /**
         * The validate function which returns true or false.
         */
        validate: function() {
            return this.$.password.validate() && (this.noValidation || this._validPassword());
        },

        /**
         * A method to focus on the password input.
         */
        focus: function() {
            this.$.password.querySelector('input').focus();
        },

        _updateRegexRules: function() {

            if (this.noValidation)
                return;

            var modifiedRules = [];
            var regexItemKeys = ['message', 'regex'];
            var validJson = true;
            var defaultRules = this.noDefaultValidation ? [] : this.defaultRegexRules;

            //apply default rules if custom rules are not provided
            if (!this.customRegexRules) {
                for (var i = 0; i < defaultRules.length; i++)
                    modifiedRules.push(defaultRules[i][Object.keys(defaultRules[i])[0]]);
                this._setRegexRules(modifiedRules);
                return;
            }

            //parse stringified custom rules json
            try {
                var customRules = JSON.parse(this.customRegexRules);
            } catch (e) {
                console.error('error in parsing stringified regex json ', e);
            }
            if (customRules && typeof customRules === 'Array' && customRules.length)
                return;

            //check if parsed custom rules have required properties.
            customRules.forEach(function(customRule, index) {
                var customRuleKey = Object.keys(customRule)[0];
                var customKeys = Object.keys(customRule[customRuleKey]);
                for (var i = 0; i < regexItemKeys.length; i++) {
                    if (validJson && customKeys.indexOf(regexItemKeys[i]) < 0)
                        validJson = false;
                };

                if (!validJson) {
                    console.error(customRuleKey, ' is either missing \'message\' or \'regex\' string property');
                    return;
                }
            });

            //Add all default rules
            //Override them if matching custom rule is found
            defaultRules.forEach(function(defaultRule, index) {
                var defaultRuleKey = Object.keys(defaultRule)[0];
                var modifiedRule = customRules.filter(function(item, index) {
                    return Object.keys(item)[0] === defaultRuleKey;
                });
                if (!modifiedRule.length) {
                    modifiedRule = defaultRules.filter(function(item, index) {
                        return Object.keys(item)[0] === defaultRuleKey;
                    });
                    modifiedRules.push(modifiedRule[0][Object.keys(modifiedRule[0])[0]]);
                } else {
                    modifiedRules.push(defaultRule[Object.keys(defaultRule)[0]]);
                }
            }, this);

            //add custom rules which are new
            customRules.forEach(function(customRule, index) {
                var customRuleKey = Object.keys(customRule)[0];
                var customKeys = Object.keys(customRule[customRuleKey]);

                var modifiedRule = defaultRules.filter(function(item, index) {
                    return Object.keys(item)[0] === customRuleKey;
                });

                if (!modifiedRule.length)
                    modifiedRules.push(customRule[customRuleKey]);
            }, this);

            //set the regexRules property
            this._setRegexRules(modifiedRules);

        },

        _validateRegex: function(e, data) {
            if (this.noValidation || !this.regexRules) {
                return;
            }

            this.regexRules.forEach(function(item, index, array) {
                var statusProperty = 'regexRules.' + index + '.status';
                var isMatchedProperty = 'regexRules.' + index + '.isMatched';

                if (!data.value) {
                    this.set(statusProperty, 'base');
                } else if (data.value.match(item.regex)) {
                    this.set(statusProperty, 'valid');
                    this.set(isMatchedProperty, true);
                } else {
                    this.set(statusProperty, 'invalid');
                    this.set(isMatchedProperty, false);
                }
            }, this);
        },

        _togglePaswordVisibility: function(e) {
            if (this._toggleClass == 'Show') {
                this.$.password.type = 'text';
                this._toggleClass = 'Hide';
            } else {
                this.$.password.type = 'password';
                this._toggleClass = 'Show';
            }
            this.focus();
        },

        _validPassword: function() {
            var isValid = true;
            for (var i = 0; i < this.regexRules.length; i++) {
                isValid = this.regexRules[i].isMatched && isValid;
            }
            return isValid;
        }
    });

</script>
